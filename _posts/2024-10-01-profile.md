---
title: profile 관리
excerpt: 
categories:
  - tripot
tags: 
permalink: /project/tripot/profile
toc: true
toc_sticky: true
date: 2024-10-01
last_modified_at: 2024-10-01
---
아래 내용은 사이드 프로젝트(tripot)를 진행하면서 겪은 문제를 정리한 것입니다.  

---
새로운 프로젝트를 시작하며 멀티 프로필을 적용하고자 한다.

---
# profile 관리
멀티 모듈을 사용하면서 property를 관리하는 `applicaiton.yml`도 모듈 별로 여러 개를 가지게 되었다.  

# application.yml 분리
멀티모듈을 `domain, api, common` 3개로 나눴기 때문에 그에 따라 property 관리도 `application-domain.yml`, `application-api.yml`, `application-common.yml` 3개로 나눠서 하게 되었다.  
그리고 `local환경`, `prod환경`에 따라 추가적으로 2개씩 나뉘게 되었다.  

api 모듈
+ application.yml
+ application-api-local.yml
+ application-api-prod.yml

domain 모듈
+ application-domain-local.yml
+ application-domain-prod.yml

common 모듈
+ application-common-local.yml
+ application-common-prod.yml

`api모듈`을 통해서 웹 서버가 동작하기 때문에 `api모듈`을 통해서 다른 모듈의 `application.yml`정보를 읽을 수 있도록 해야 한다.  

# api 모듈 

## application.yml
``` yml
spring:  
  application:  
    name: module-api  
  profiles:  
    group:  
      "local": "local"  
      "prod": "prod"
```

`api모듈`에서 웹 서버를 실행시키면 우선적으로 `application.yml`파일을 찾으려고 한다.  그래서 `api모듈`에만 `application.yml`파일이 따로 존재하는 이유이다.  

`spring.profiles.group`을 통해 현재 실행되는 `active`가 무엇이냐에 따라 어떤 `profile`을 선택할지 묶어서 선택할 수 있다. 현재는 `local`이 active일 경우 `local` profile만, `prod`가 active일 경우 `prod` profile만 실행되도록 해 놓았다. 만약 여러 개를 사용하고 싶은 경우 "local, domain" 처럼 사용하면 된다.  

`local`, `prod`를 active시키는 방법은 파라미터로 `--spring.profiles.active={실행 profile}` 를 넣어주면 된다.  `{실행 profile}` 위치에 `local`, `prod` 를 넣어주면 된다.  

## application-api-local.yml
``` yml
cloud:  
  aws:  
    s3:  
      bucket: tripot  
      path:  
        profile: user/profile  
        story: story/image  
      region:  
        static: eu-north-1  
      stack:  
        auto: false  
      credentials:  
        accessKey: ${AWS_S3_ACCESS_KEY_ID}  
        secretKey: ${AWS_S3_SECRET_ACCESS_KEY}  
  
spring:  
  servlet:  
    multipart:  
      max-file-size: 5MB  
      max-request-size: 50MB  
```
`application-api-local.yml`은 실제 `api모듈`에서 사용하는 설정 정보들을 작성했다. 만약 운영 환경에서 다른 정보가 쓰인다면 `application-api-prod.yml`에 작성하면 된다.  

---
## PropertySource 옵션
``` java
@PropertySource(ignoreResourceNotFound = true,  
        value = {  
                "classpath:application-domain-${spring.profiles.active}.yml",  
                "classpath:application-common-${spring.profiles.active}.yml",  
                "classpath:application-api-${spring.profiles.active}.yml"  
        }, factory = YamlPropertySourceFactory.class  
)  
public class ScanConfig {  
}
```

``` java
public class YamlPropertySourceFactory implements PropertySourceFactory {  
    @Override  
    public PropertySource<?> createPropertySource(String name, EncodedResource resource) throws IOException {  
        YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();  
        factory.setResources(resource.getResource());  
        Properties properties = factory.getObject();  
        return new PropertiesPropertySource(resource.getResource().getFilename(), properties);  
  
    }  
}
```

### ScanConfig
`@PropertySOurce`의 `value`를 보면 다음과 값들이 들어가 있다.  
```java
"classpath:application-domain-${spring.profiles.active}.yml",
"classpath:application-common-${spring.profiles.active}.yml",  
"classpath:application-api-${spring.profiles.active}.yml"
```

`${spring.profiles.active}` 를 통해 `local`, `prod` 값이 들어가기 떄문에 결과적으로 다음과 같은 값이 설정될 것이다.  

```java
// 만약 local을 설정했다면
"classpath:application-domain-local.yml",
"classpath:application-common-local.yml",  
"classpath:application-api-local.yml"

// 만약 prod를 설정했다면 
"classpath:application-domain-prod.yml",
"classpath:application-common-prod.yml",  
"classpath:application-api-prod.yml"
```


### YamlPropertySourceFactory
`@PropertySource`는 기본적으로 `application.properties`를 사용하기에 `yml, yaml`파일을 사용하기 위해서는 팩토리를 통해 사용할 수 있도록 해야한다.  

---
## PropertySource 다른 사용법
Property를 사용하는 클래스에서 `@PropertySource(value= {property 경로}`를 통해 원하는 `application.yml`을 직접 참조할 수도 있다.  

효율적인 측면을 보자면 원하는 property만 참조시키는 방법이 더 좋아 보이지만 클래스마다 따로 지정을 해야 한다.  
멀티모듈을 사용한다고 해도 프로젝트 크기가 작기 때문에 한번에 다 불러오는 방법이 관리 측면에서 더 유리하다고 생각하기 때문에 처음 서술한 방식을 선택했다.  

---
# 후기
예전이었다면 필요한 정보는 필요한 곳에만 쓰여야지! 하면서 `@PropertySource`를 필요한 곳마다 선언해서 사용했겠지만 관리의 편의성도 생각하게 되면서 한번에 불러오는 방법도 나쁘지는 않구나 라는 생각을 하게 된다.  